#!/usr/bin/env python3
"""Solve a problem instance with Google OR-Tools and produce map-ready route output.

Purpose:
- Read a problem-instance file (JSON content; often saved with `.csv` extension).
- Solve a vehicle-routing problem (VRP) with OR-Tools using a selected cost matrix.
- Write a solution CSV that matches the column structure used by
  `data_geocode/latest/data_geocode.csv`, so `visualizations/viz_map_routes_on_road.py`
  can load it directly.
- Optionally run that visualizer automatically and generate an HTML route map.

Main inputs:
- `stops`: ordered stop list from the problem instance.
- `travel_time_matrix_seconds` or `travel_distance_matrix_meters`: N x N cost matrix.
- Depot is assumed to be node index `0`; depot display/lat/lon are loaded from
  `visualizations/persistent_depot_address.csv` when available.
- `ROUTING_CONSTRAINTS`: list of typed constraint objects (currently `FirstStop`).

Main outputs:
- Solution CSV with data_geocode-compatible columns.
- Optional visualization HTML generated by `viz_map_routes_on_road.py`.

Execution flow:
1. Load and validate the instance JSON.
2. Select and normalize the chosen cost matrix (replace null/invalid arcs with a large penalty).
3. Build and solve an OR-Tools routing model.
   - During model build, scan `ROUTING_CONSTRAINTS` by `type` and apply supported constraints.
4. Extract per-vehicle routes from the solved model.
5. Convert routes into data_geocode-compatible rows and write CSV.
6. Invoke the map visualizer on that CSV (unless `--skip-viz` is used).

Quick example:
  ./.venv/bin/python optimize/solve_problem_ortools.py \
    optimize/problem_instance_2024_11_01.csv \
    --num-vehicles 4 \
    --time-limit-seconds 30 \
    --cost-field travel_time_matrix_seconds \
    --output optimize/solution_ortools_2024_11_01.csv \
    --viz-output optimize/solution_ortools_2024_11_01.html
"""

from __future__ import annotations

import argparse
import csv
import json
import math
import subprocess
import sys
from pathlib import Path
from typing import Any

try:
    from ortools.constraint_solver import pywrapcp, routing_enums_pb2
except ModuleNotFoundError as exc:  # pragma: no cover - runtime dependency guard
    raise SystemExit(
        "This script requires Google OR-Tools. Install it in the project venv, for example:\n"
        "./.venv/bin/pip install ortools"
    ) from exc


SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
DEFAULT_VIZ_SCRIPT = SCRIPT_DIR / "viz_solution.py"
DEFAULT_DEPOT_CSV = PROJECT_ROOT / "visualizations" / "persistent_depot_address.csv"

DATA_GEOCODE_COLUMNS = [
    "Driver",
    "Order ID",
    "Location",
    "Address",
    "Order Type",
    "Status",
    "Planned Stop Number",
    "Planned Date",
    "Planned Time",
    "Planned Duration",
    "Actual Stop Number",
    "Actual Date",
    "Actual Time",
    "Actual Duration",
    "Notes",
    "PoD - Note",
    "Photos",
    "Rating",
    "Comment",
    "osm_id",
    "display_name",
    "latitude",
    "longitude",
]

FIRST_SOLUTION_STRATEGIES = {
    "AUTOMATIC": routing_enums_pb2.FirstSolutionStrategy.AUTOMATIC,
    "PATH_CHEAPEST_ARC": routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC,
    "PARALLEL_CHEAPEST_INSERTION": routing_enums_pb2.FirstSolutionStrategy.PARALLEL_CHEAPEST_INSERTION,
    "SAVINGS": routing_enums_pb2.FirstSolutionStrategy.SAVINGS,
    "CHRISTOFIDES": routing_enums_pb2.FirstSolutionStrategy.CHRISTOFIDES,
}

LOCAL_SEARCH_METAHEURISTICS = {
    "AUTOMATIC": routing_enums_pb2.LocalSearchMetaheuristic.AUTOMATIC,
    "GREEDY_DESCENT": routing_enums_pb2.LocalSearchMetaheuristic.GREEDY_DESCENT,
    "GUIDED_LOCAL_SEARCH": routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH,
    "SIMULATED_ANNEALING": routing_enums_pb2.LocalSearchMetaheuristic.SIMULATED_ANNEALING,
    "TABU_SEARCH": routing_enums_pb2.LocalSearchMetaheuristic.TABU_SEARCH,
}

# Central constraint registry. Add new dictionaries for future constraint types.
ROUTING_CONSTRAINTS: list[dict[str, Any]] = [
    {
        "type": "FirstStop",
        "display_name": "201, Branch Avenue, Providence, Providence County, Rhode Island, 02904, United States",
    },
    {
        "type": "FirstStop",
        "display_name": "1014, Kings Highway, New Bedford, Bristol County, Massachusetts, 02745, United States",
    },
    {
        "type": "FirstStop",
        "display_name": "Davenport's Bar and Grille, 1925, Pawtucket Avenue, Carpenters Corner, East Providence, Providence County, Rhode Island, 02914, United States",
    },
]


def log(message: str, quiet: bool) -> None:
    if not quiet:
        print(f"[solve_problem_ortools] {message}")


def format_coord(value: Any) -> str:
    if value is None:
        return ""
    try:
        number = float(value)
    except (TypeError, ValueError):
        return ""
    if math.isnan(number):
        return ""
    return f"{number:.8f}"


def format_duration(value: Any) -> str:
    if value is None:
        return ""
    try:
        number = float(value)
    except (TypeError, ValueError):
        return ""
    if math.isnan(number):
        return ""
    rounded = round(number, 3)
    if float(rounded).is_integer():
        return str(int(rounded))
    return f"{rounded:.3f}".rstrip("0").rstrip(".")


def build_stop_service_seconds(
    stops: list[dict[str, Any]],
    depot_index: int,
) -> tuple[list[int], int]:
    service_seconds: list[int] = []
    missing_or_invalid_count = 0

    for node_idx, stop in enumerate(stops):
        if node_idx == depot_index:
            service_seconds.append(0)
            continue

        value = stop.get("mean_stop_duration") if isinstance(stop, dict) else None
        if value is None:
            service_seconds.append(0)
            missing_or_invalid_count += 1
            continue

        try:
            minutes = float(value)
        except (TypeError, ValueError):
            service_seconds.append(0)
            missing_or_invalid_count += 1
            continue

        if math.isnan(minutes) or minutes < 0:
            service_seconds.append(0)
            missing_or_invalid_count += 1
            continue

        service_seconds.append(max(0, int(round(minutes * 60.0))))

    return service_seconds, missing_or_invalid_count


def load_instance(instance_path: Path) -> dict[str, Any]:
    try:
        return json.loads(instance_path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise SystemExit(
            f"Instance file is not valid JSON: {instance_path}\n"
            "Note: problem instance files use .csv extension but contain JSON."
        ) from exc


def load_persistent_depot(depot_csv_path: Path, quiet: bool) -> dict[str, Any] | None:
    if not depot_csv_path.exists():
        log(f"Depot CSV not found, using depot from instance: {depot_csv_path}", quiet=quiet)
        return None

    try:
        with depot_csv_path.open("r", encoding="utf-8", newline="") as file_obj:
            reader = csv.DictReader(file_obj)
            for row in reader:
                display_name = str(row.get("display_name", "")).strip()
                if not display_name:
                    continue
                try:
                    latitude = float(row.get("latitude", ""))
                    longitude = float(row.get("longitude", ""))
                except (TypeError, ValueError):
                    continue
                if math.isnan(latitude) or math.isnan(longitude):
                    continue
                return {
                    "display_name": display_name,
                    "latitude": latitude,
                    "longitude": longitude,
                }
    except OSError as exc:
        log(
            f"Could not read depot CSV ({depot_csv_path}); using instance depot. {exc}",
            quiet=quiet,
        )
        return None

    log(
        f"No valid depot row in {depot_csv_path}; using depot from instance.",
        quiet=quiet,
    )
    return None


def _normalize_text(value: Any) -> str:
    if value is None:
        return ""
    return str(value).strip().casefold()


def _constraint_is_enabled(value: Any) -> bool:
    if isinstance(value, bool):
        return value
    text = str(value).strip().lower()
    if not text:
        return True
    return text not in {"0", "false", "f", "no", "n", "off"}


def _get_constraints_by_type(
    constraints: list[dict[str, Any]],
    constraint_type: str,
) -> list[dict[str, Any]]:
    match_type = _normalize_text(constraint_type)
    selected: list[dict[str, Any]] = []
    for item in constraints:
        if not isinstance(item, dict):
            continue
        if not _constraint_is_enabled(item.get("enabled", True)):
            continue
        if _normalize_text(item.get("type")) == match_type:
            selected.append(item)
    return selected


def _get_enabled_constraints(constraints: list[dict[str, Any]]) -> list[dict[str, Any]]:
    enabled_constraints: list[dict[str, Any]] = []
    for constraint in constraints:
        if not isinstance(constraint, dict):
            continue
        if not _constraint_is_enabled(constraint.get("enabled", True)):
            continue
        enabled_constraints.append(constraint)
    return enabled_constraints


def _resolve_first_stop_nodes(
    stops: list[dict[str, Any]],
    constraints: list[dict[str, Any]],
    quiet: bool,
) -> list[dict[str, Any]]:
    first_stop_constraints = _get_constraints_by_type(constraints, "FirstStop")
    if not first_stop_constraints:
        return []

    display_to_node_indices: dict[str, list[int]] = {}
    for node_idx, stop in enumerate(stops):
        if node_idx == 0:
            continue  # depot
        if not isinstance(stop, dict):
            continue
        display_name_norm = _normalize_text(stop.get("display_name"))
        if not display_name_norm:
            continue
        display_to_node_indices.setdefault(display_name_norm, []).append(node_idx)

    selected_entries: list[dict[str, Any]] = []
    used_nodes: set[int] = set()
    for constraint in first_stop_constraints:
        display_name = str(constraint.get("display_name", "")).strip()
        display_name_norm = _normalize_text(display_name)
        if not display_name_norm:
            continue
        matching_nodes = display_to_node_indices.get(display_name_norm, [])
        if not matching_nodes:
            log(
                f"FirstStop constraint not found in instance stops, skipping: {display_name}",
                quiet=quiet,
            )
            continue

        node_idx = next((idx for idx in matching_nodes if idx not in used_nodes), None)
        if node_idx is None:
            log(
                f"FirstStop constraint has no unused node match, skipping: {display_name}",
                quiet=quiet,
            )
            continue
        used_nodes.add(node_idx)

        vehicle_idx_raw = constraint.get("vehicle_index", None)
        vehicle_idx: int | None
        if vehicle_idx_raw is None or str(vehicle_idx_raw).strip() == "":
            vehicle_idx = None
        else:
            try:
                vehicle_idx = int(vehicle_idx_raw)
            except (TypeError, ValueError):
                raise SystemExit(
                    "FirstStop constraint vehicle_index must be an integer when provided: "
                    f"{constraint!r}"
                )

        selected_entries.append(
            {
                "display_name": display_name,
                "node_idx": int(node_idx),
                "vehicle_index": vehicle_idx,
            }
        )

    return selected_entries


def apply_routing_constraints(
    routing: pywrapcp.RoutingModel,
    manager: pywrapcp.RoutingIndexManager,
    stops: list[dict[str, Any]],
    num_vehicles: int,
    constraints: list[dict[str, Any]],
    quiet: bool,
) -> None:
    first_stop_entries = _resolve_first_stop_nodes(stops=stops, constraints=constraints, quiet=quiet)
    if not first_stop_entries:
        return

    if len(first_stop_entries) > num_vehicles:
        raise SystemExit(
            "Infeasible FirstStop constraints: "
            f"{len(first_stop_entries)} constrained stops for {num_vehicles} vehicles."
        )

    solver = routing.solver()
    available_vehicle_indices: list[int] = list(range(num_vehicles))
    assigned_vehicle_indices: set[int] = set()
    applied_pairs: list[tuple[int, int, str]] = []

    for entry in first_stop_entries:
        node_idx = int(entry["node_idx"])
        display_name = str(entry.get("display_name", "")).strip()
        specified_vehicle_idx = entry.get("vehicle_index", None)

        if specified_vehicle_idx is None:
            if not available_vehicle_indices:
                raise SystemExit(
                    "Infeasible FirstStop constraints: not enough available vehicles to assign constraints."
                )
            vehicle_idx = available_vehicle_indices.pop(0)
        else:
            vehicle_idx = int(specified_vehicle_idx)
            if vehicle_idx < 0 or vehicle_idx >= num_vehicles:
                raise SystemExit(
                    "FirstStop constraint vehicle_index out of range: "
                    f"{vehicle_idx} (num_vehicles={num_vehicles})"
                )
            if vehicle_idx in assigned_vehicle_indices:
                raise SystemExit(
                    "Duplicate FirstStop constraint for vehicle_index "
                    f"{vehicle_idx}. Only one FirstStop is allowed per vehicle."
                )
            if vehicle_idx in available_vehicle_indices:
                available_vehicle_indices.remove(vehicle_idx)

        assigned_vehicle_indices.add(vehicle_idx)
        start_index = routing.Start(vehicle_idx)
        node_index = manager.NodeToIndex(node_idx)
        solver.Add(routing.NextVar(start_index) == node_index)
        applied_pairs.append((vehicle_idx, node_idx, display_name))

    for vehicle_idx, node_idx, display_name in applied_pairs:
        log(
            f"Applied FirstStop constraint: vehicle={vehicle_idx + 1}, node={node_idx}, "
            f"display_name={display_name}",
            quiet=quiet,
        )


def normalize_cost_matrix(
    raw_matrix: Any,
    stop_count: int,
    unreachable_penalty_arg: int | None,
) -> tuple[list[list[int]], int, int]:
    if not isinstance(raw_matrix, list) or len(raw_matrix) != stop_count:
        raise SystemExit(
            f"Cost matrix shape mismatch: expected {stop_count} rows, got "
            f"{len(raw_matrix) if isinstance(raw_matrix, list) else 'non-list'}."
        )

    finite_values: list[float] = []
    for row in raw_matrix:
        if not isinstance(row, list) or len(row) != stop_count:
            raise SystemExit("Cost matrix must be a square list of lists with shape N x N.")
        for value in row:
            if value is None:
                continue
            try:
                number = float(value)
            except (TypeError, ValueError):
                continue
            if math.isnan(number) or number < 0:
                continue
            finite_values.append(number)

    if unreachable_penalty_arg is not None:
        unreachable_penalty = max(1, int(unreachable_penalty_arg))
    else:
        max_finite = max(finite_values) if finite_values else 1000.0
        unreachable_penalty = int(max(100000.0, max_finite * 1000.0))
        unreachable_penalty = min(unreachable_penalty, 2_000_000_000)

    normalized: list[list[int]] = []
    unreachable_arc_count = 0

    for i, row in enumerate(raw_matrix):
        normalized_row: list[int] = []
        for j, value in enumerate(row):
            if i == j:
                normalized_row.append(0)
                continue

            if value is None:
                normalized_row.append(unreachable_penalty)
                unreachable_arc_count += 1
                continue

            try:
                number = float(value)
            except (TypeError, ValueError):
                normalized_row.append(unreachable_penalty)
                unreachable_arc_count += 1
                continue

            if math.isnan(number) or number < 0:
                normalized_row.append(unreachable_penalty)
                unreachable_arc_count += 1
                continue

            normalized_row.append(max(1, int(round(number))))
        normalized.append(normalized_row)

    return normalized, unreachable_penalty, unreachable_arc_count


def solve_routes(
    cost_matrix: list[list[int]],
    route_time_matrix: list[list[int]] | None,
    stop_service_seconds: list[int] | None,
    max_route_duration_seconds: int | None,
    stops: list[dict[str, Any]],
    constraints: list[dict[str, Any]],
    num_vehicles: int,
    depot_index: int,
    max_stops_per_vehicle: int | None,
    time_limit_seconds: int,
    first_solution_strategy: str,
    local_search_metaheuristic: str,
    log_search: bool,
    quiet: bool,
) -> tuple[list[dict[str, Any]], int]:
    if num_vehicles < 1:
        raise SystemExit("--num-vehicles must be >= 1")

    manager = pywrapcp.RoutingIndexManager(len(cost_matrix), num_vehicles, depot_index)
    routing = pywrapcp.RoutingModel(manager)

    def transit_callback(from_index: int, to_index: int) -> int:
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return int(cost_matrix[from_node][to_node])

    transit_idx = routing.RegisterTransitCallback(transit_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_idx)

    if max_stops_per_vehicle is not None:
        max_stops_per_vehicle = max(1, int(max_stops_per_vehicle))

        def stop_demand_callback(index: int) -> int:
            node = manager.IndexToNode(index)
            return 0 if node == depot_index else 1

        demand_idx = routing.RegisterUnaryTransitCallback(stop_demand_callback)
        routing.AddDimensionWithVehicleCapacity(
            demand_idx,
            0,
            [max_stops_per_vehicle] * num_vehicles,
            True,
            "StopCount",
        )

    if max_route_duration_seconds is not None:
        if route_time_matrix is None:
            raise SystemExit(
                "Internal error: route_time_matrix is required when max_route_duration_seconds is set."
            )
        if stop_service_seconds is None:
            raise SystemExit(
                "Internal error: stop_service_seconds is required when max_route_duration_seconds is set."
            )
        if len(route_time_matrix) != len(cost_matrix):
            raise SystemExit(
                "Route-time matrix length mismatch with cost matrix length."
            )
        if len(stop_service_seconds) != len(cost_matrix):
            raise SystemExit(
                "Service-time vector length mismatch with stop count."
            )

        route_duration_limit = max(1, int(max_route_duration_seconds))

        def route_duration_callback(from_index: int, to_index: int) -> int:
            from_node = manager.IndexToNode(from_index)
            to_node = manager.IndexToNode(to_index)
            travel_seconds = int(route_time_matrix[from_node][to_node])
            service_seconds = 0 if from_node == depot_index else int(stop_service_seconds[from_node])
            return travel_seconds + service_seconds

        route_duration_idx = routing.RegisterTransitCallback(route_duration_callback)
        routing.AddDimension(
            route_duration_idx,
            0,
            route_duration_limit,
            True,
            "RouteDuration",
        )

    apply_routing_constraints(
        routing=routing,
        manager=manager,
        stops=stops,
        num_vehicles=num_vehicles,
        constraints=constraints,
        quiet=quiet,
    )

    params = pywrapcp.DefaultRoutingSearchParameters()
    params.first_solution_strategy = FIRST_SOLUTION_STRATEGIES[first_solution_strategy]
    params.local_search_metaheuristic = LOCAL_SEARCH_METAHEURISTICS[local_search_metaheuristic]
    params.time_limit.seconds = max(1, int(time_limit_seconds))
    params.log_search = bool(log_search)

    solution = routing.SolveWithParameters(params)
    if solution is None:
        raise SystemExit("OR-Tools could not find a feasible solution.")

    routes: list[dict[str, Any]] = []
    for vehicle_idx in range(num_vehicles):
        index = routing.Start(vehicle_idx)
        route_nodes = [manager.IndexToNode(index)]
        route_cost = 0

        while not routing.IsEnd(index):
            next_index = solution.Value(routing.NextVar(index))
            route_cost += routing.GetArcCostForVehicle(index, next_index, vehicle_idx)
            index = next_index
            route_nodes.append(manager.IndexToNode(index))

        if len(route_nodes) > 2:
            routes.append(
                {
                    "vehicle_index": vehicle_idx,
                    "nodes": route_nodes,
                    "route_cost": int(route_cost),
                }
            )

    return routes, int(solution.ObjectiveValue())


def build_solution_rows(
    routes: list[dict[str, Any]],
    stops: list[dict[str, Any]],
    route_date: str,
    driver_prefix: str,
) -> list[dict[str, Any]]:
    rows: list[dict[str, Any]] = []

    for route in routes:
        vehicle_index = int(route["vehicle_index"])
        driver_name = f"{driver_prefix} {vehicle_index + 1}"
        nodes = route["nodes"]

        for seq_idx, node_idx in enumerate(nodes, start=1):
            stop = stops[node_idx]
            display_name = str(stop.get("display_name", "")).strip() or f"STOP {node_idx}"
            lat = format_coord(stop.get("latitude"))
            lon = format_coord(stop.get("longitude"))
            mean_stop_duration = format_duration(stop.get("mean_stop_duration"))

            row = {col: "" for col in DATA_GEOCODE_COLUMNS}
            row["Driver"] = driver_name
            row["Order ID"] = f"{driver_name.replace(' ', '_')}_{seq_idx:03d}"
            row["Location"] = display_name
            row["Address"] = display_name
            row["Order Type"] = "Pickup"
            row["Status"] = "Planned"
            row["Planned Stop Number"] = str(seq_idx)
            row["Planned Date"] = route_date
            row["Actual Stop Number"] = str(seq_idx)
            row["Actual Date"] = route_date
            row["Actual Duration"] = mean_stop_duration
            row["display_name"] = display_name
            row["latitude"] = lat
            row["longitude"] = lon
            rows.append(row)

    return rows


def write_solution_csv(solution_csv_path: Path, rows: list[dict[str, Any]]) -> None:
    solution_csv_path.parent.mkdir(parents=True, exist_ok=True)
    with solution_csv_path.open("w", newline="", encoding="utf-8") as file_obj:
        writer = csv.DictWriter(file_obj, fieldnames=DATA_GEOCODE_COLUMNS)
        writer.writeheader()
        writer.writerows(rows)


def run_visualization(
    python_executable: str,
    viz_script: Path,
    input_csv: Path,
    output_html: Path,
    start_date: str,
    end_date: str,
    constraints: list[dict[str, Any]],
    quiet: bool,
) -> None:
    constraints_json = json.dumps(constraints, ensure_ascii=False)
    command = [
        python_executable,
        str(viz_script),
        str(input_csv),
        "--start-date",
        start_date,
        "--end-date",
        end_date,
        "--output",
        str(output_html),
        "--constraints-json",
        constraints_json,
    ]

    log("Running side-by-side solution visualizer...", quiet=quiet)
    subprocess.run(command, check=True)
    log(f"Comparison visualizer output saved: {output_html}", quiet=quiet)


def derive_default_paths(instance_path: Path) -> tuple[Path, Path]:
    stem = instance_path.stem
    if stem.startswith("problem_instance_"):
        suffix = stem.replace("problem_instance_", "", 1)
    else:
        suffix = stem

    solution_csv = SCRIPT_DIR / f"solution_ortools_{suffix}.csv"
    solution_html = SCRIPT_DIR / f"solution_ortools_{suffix}.html"
    return solution_csv.resolve(), solution_html.resolve()


def main() -> None:
    parser = argparse.ArgumentParser(
        description=(
            "Read a problem instance JSON file, solve with Google OR-Tools VRP, "
            "write a data_geocode-compatible solution CSV, and run route visualization."
        )
    )
    parser.add_argument(
        "instance",
        help="Path to problem instance file (JSON content, typically .csv extension).",
    )
    parser.add_argument(
        "--output",
        default="",
        help="Output solution CSV path. Defaults to optimize/solution_ortools_*.csv",
    )
    parser.add_argument(
        "--viz-output",
        default="",
        help="Output HTML path for side-by-side actual-vs-solution comparison map.",
    )
    parser.add_argument(
        "--viz-script",
        default=str(DEFAULT_VIZ_SCRIPT),
        help="Path to optimize/viz_solution.py",
    )
    parser.add_argument(
        "--python-executable",
        default=sys.executable,
        help="Python executable used to invoke viz script.",
    )
    parser.add_argument(
        "--skip-viz",
        action="store_true",
        help="Skip running comparison visualization after solving.",
    )
    parser.add_argument(
        "--num-vehicles",
        type=int,
        default=4,
        help="Number of vehicles (drivers) for OR-Tools.",
    )
    parser.add_argument(
        "--max-stops-per-vehicle",
        type=int,
        default=0,
        help=(
            "Maximum non-depot stops per vehicle. "
            "Use 0 (default) for automatic balancing ceil((N-1)/num_vehicles)."
        ),
    )
    parser.add_argument(
        "--no-stop-cap",
        action="store_true",
        help="Disable per-vehicle stop-cap balancing constraint.",
    )
    parser.add_argument(
        "--max-route-minutes",
        type=float,
        default=0.0,
        help=(
            "Maximum route duration per vehicle in minutes, where duration is "
            "travel_time + stop_service_time(mean_stop_duration). "
            "Use 0 (default) to disable."
        ),
    )
    parser.add_argument(
        "--driver-prefix",
        default="Vehicle",
        help='Driver name prefix for CSV rows (default: "Vehicle").',
    )
    parser.add_argument(
        "--cost-field",
        default="travel_time_matrix_seconds",
        choices=["travel_time_matrix_seconds", "travel_distance_matrix_meters"],
        help="Matrix field used as objective cost.",
    )
    parser.add_argument(
        "--unreachable-penalty",
        type=int,
        default=None,
        help="Penalty used when matrix entry is null/invalid. Defaults to auto-scaling.",
    )
    parser.add_argument(
        "--time-limit-seconds",
        type=int,
        default=20,
        help="OR-Tools solve time limit in seconds.",
    )
    parser.add_argument(
        "--first-solution-strategy",
        default="PATH_CHEAPEST_ARC",
        choices=sorted(FIRST_SOLUTION_STRATEGIES.keys()),
        help="OR-Tools first solution strategy.",
    )
    parser.add_argument(
        "--local-search-metaheuristic",
        default="GUIDED_LOCAL_SEARCH",
        choices=sorted(LOCAL_SEARCH_METAHEURISTICS.keys()),
        help="OR-Tools local-search metaheuristic.",
    )
    parser.add_argument(
        "--log-search",
        action="store_true",
        help="Enable verbose OR-Tools search logs.",
    )
    parser.add_argument(
        "--route-date",
        default="",
        help="Override date written to Planned Date / Actual Date in output CSV.",
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="Reduce script logs.",
    )
    args = parser.parse_args()

    quiet = bool(args.quiet)
    instance_path = Path(args.instance).expanduser().resolve()
    if not instance_path.exists():
        raise SystemExit(f"Instance file not found: {instance_path}")

    default_solution_csv, default_solution_html = derive_default_paths(instance_path)
    solution_csv_path = (
        Path(args.output).expanduser().resolve() if str(args.output).strip() else default_solution_csv
    )
    solution_html_path = (
        Path(args.viz_output).expanduser().resolve()
        if str(args.viz_output).strip()
        else default_solution_html
    )

    log(f"Loading instance: {instance_path}", quiet=quiet)
    instance = load_instance(instance_path)

    stops = instance.get("stops")
    if not isinstance(stops, list) or not stops:
        raise SystemExit("Instance is missing a non-empty `stops` list.")

    stop_count = int(instance.get("stop_count", len(stops)))
    if stop_count != len(stops):
        raise SystemExit(
            f"Instance mismatch: stop_count={stop_count}, but len(stops)={len(stops)}."
        )

    stops_with_mean_duration = sum(
        1
        for stop in stops
        if isinstance(stop, dict) and stop.get("mean_stop_duration") is not None
    )
    if stops_with_mean_duration == 0:
        log(
            "No `mean_stop_duration` values found in instance stops. "
            "Output CSV `Actual Duration` values will be blank.",
            quiet=quiet,
        )
    else:
        log(
            f"Found mean_stop_duration on {stops_with_mean_duration}/{len(stops)} stops.",
            quiet=quiet,
        )

    depot_override = load_persistent_depot(DEFAULT_DEPOT_CSV, quiet=quiet)
    if depot_override is not None:
        if not isinstance(stops[0], dict):
            raise SystemExit("Instance depot stop at index 0 must be an object/dict.")
        stops = list(stops)
        depot_stop = dict(stops[0])
        depot_stop["display_name"] = depot_override["display_name"]
        depot_stop["latitude"] = depot_override["latitude"]
        depot_stop["longitude"] = depot_override["longitude"]
        stops[0] = depot_stop
        log(
            "Using depot from persistent_depot_address.csv: "
            f"{depot_override['display_name']} "
            f"({depot_override['latitude']:.8f}, {depot_override['longitude']:.8f})",
            quiet=quiet,
        )

    cost_field = str(args.cost_field)
    if cost_field not in instance:
        available = [k for k in ("travel_time_matrix_seconds", "travel_distance_matrix_meters") if k in instance]
        raise SystemExit(
            f"Cost field {cost_field!r} not found in instance. Available matrix fields: {available}"
        )

    log(
        f"Preparing cost matrix from `{cost_field}` for {stop_count} stops "
        f"(depot index expected at 0).",
        quiet=quiet,
    )
    cost_matrix, unreachable_penalty, unreachable_arc_count = normalize_cost_matrix(
        raw_matrix=instance[cost_field],
        stop_count=stop_count,
        unreachable_penalty_arg=args.unreachable_penalty,
    )
    log(
        f"Unreachable arc penalty: {unreachable_penalty} "
        f"| substituted arcs: {unreachable_arc_count}",
        quiet=quiet,
    )

    log(
        f"Solving OR-Tools VRP with {args.num_vehicles} vehicles, "
        f"time_limit={max(1, int(args.time_limit_seconds))}s...",
        quiet=quiet,
    )
    non_depot_count = max(0, stop_count - 1)
    if args.no_stop_cap:
        max_stops_per_vehicle: int | None = None
    elif int(args.max_stops_per_vehicle) > 0:
        max_stops_per_vehicle = int(args.max_stops_per_vehicle)
    else:
        max_stops_per_vehicle = max(
            1,
            int(math.ceil(non_depot_count / max(1, int(args.num_vehicles)))),
        )
    log(
        "Per-vehicle stop cap: "
        + ("disabled" if max_stops_per_vehicle is None else str(max_stops_per_vehicle)),
        quiet=quiet,
    )

    if float(args.max_route_minutes) < 0:
        raise SystemExit("--max-route-minutes must be >= 0.")

    if float(args.max_route_minutes) > 0:
        if cost_field == "travel_time_matrix_seconds":
            route_time_matrix = cost_matrix
        else:
            if "travel_time_matrix_seconds" not in instance:
                raise SystemExit(
                    "Route-duration cap requires travel_time_matrix_seconds in the instance."
                )
            route_time_matrix, _, _ = normalize_cost_matrix(
                raw_matrix=instance["travel_time_matrix_seconds"],
                stop_count=stop_count,
                unreachable_penalty_arg=args.unreachable_penalty,
            )

        stop_service_seconds, missing_service_count = build_stop_service_seconds(
            stops=stops,
            depot_index=0,
        )
        max_route_duration_seconds: int | None = max(1, int(round(float(args.max_route_minutes) * 60.0)))
        log(
            "Per-vehicle route-duration cap: "
            f"{float(args.max_route_minutes):.2f} min "
            "(travel + mean_stop_duration).",
            quiet=quiet,
        )
        log(
            "Stops with missing/invalid mean_stop_duration treated as 0 min: "
            f"{missing_service_count}",
            quiet=quiet,
        )
    else:
        route_time_matrix = None
        stop_service_seconds = None
        max_route_duration_seconds = None
        log("Per-vehicle route-duration cap: disabled", quiet=quiet)

    routes, objective = solve_routes(
        cost_matrix=cost_matrix,
        route_time_matrix=route_time_matrix,
        stop_service_seconds=stop_service_seconds,
        max_route_duration_seconds=max_route_duration_seconds,
        stops=stops,
        constraints=ROUTING_CONSTRAINTS,
        num_vehicles=max(1, int(args.num_vehicles)),
        depot_index=0,
        max_stops_per_vehicle=max_stops_per_vehicle,
        time_limit_seconds=max(1, int(args.time_limit_seconds)),
        first_solution_strategy=str(args.first_solution_strategy),
        local_search_metaheuristic=str(args.local_search_metaheuristic),
        log_search=bool(args.log_search),
        quiet=quiet,
    )

    used_stops = sum(len(route["nodes"]) - 2 for route in routes)
    log(
        f"Solve complete. Objective={objective} ({cost_field} units), "
        f"active_routes={len(routes)}, assigned_non_depot_stops={used_stops}",
        quiet=quiet,
    )

    start_date = str(instance.get("start_date", "")).strip()
    end_date = str(instance.get("end_date", "")).strip()
    route_date = str(args.route_date).strip() or start_date or end_date
    if not route_date:
        route_date = "1970-01-01"

    rows = build_solution_rows(
        routes=routes,
        stops=stops,
        route_date=route_date,
        driver_prefix=str(args.driver_prefix).strip() or "Vehicle",
    )
    write_solution_csv(solution_csv_path, rows)
    log(f"Wrote solution CSV: {solution_csv_path} (rows={len(rows)})", quiet=quiet)

    if not args.skip_viz:
        viz_script = Path(args.viz_script).expanduser().resolve()
        if not viz_script.exists():
            raise SystemExit(f"Visualizer script not found: {viz_script}")
        try:
            enabled_constraints = _get_enabled_constraints(ROUTING_CONSTRAINTS)
            if max_stops_per_vehicle is not None:
                enabled_constraints.append(
                    {
                        "type": "MaxStopsPerVehicle",
                        "max_stops": int(max_stops_per_vehicle),
                    }
                )
            if max_route_duration_seconds is not None:
                enabled_constraints.append(
                    {
                        "type": "MaxRouteMinutes",
                        "minutes": round(max_route_duration_seconds / 60.0, 3),
                        "definition": "travel_time + mean_stop_duration",
                    }
                )
            run_visualization(
                python_executable=str(args.python_executable),
                viz_script=viz_script,
                input_csv=solution_csv_path,
                output_html=solution_html_path,
                start_date=start_date or route_date,
                end_date=end_date or route_date,
                constraints=enabled_constraints,
                quiet=quiet,
            )
        except subprocess.CalledProcessError as exc:
            raise SystemExit(
                f"Solution CSV was written, but visualizer failed with exit code {exc.returncode}."
            ) from exc
    else:
        log("Skipping visualization step (--skip-viz).", quiet=quiet)


if __name__ == "__main__":
    main()
